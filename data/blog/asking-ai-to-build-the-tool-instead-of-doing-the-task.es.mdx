---
title: Pedir a la IA que construya la herramienta en lugar de hacer la tarea
date: "2025-06-06"
spoiler:
  Deja de pedir a la IA que realice cambios de código repetitivos directamente.
  En su lugar, pídele que construya un codemod. Esta técnica redujo nuestros
  errores de migración en un 95% y convirtió una tarea de 2 días en 2 horas.
tags:
  - ai
  - javascript
  - typescript
  - developer-tools
---

¿Y si la mejor manera de usar la IA para migraciones de código no es pedirle que
haga el trabajo, sino pedirle que construya la herramienta que lo haga? Este
enfoque contraintuitivo transformó cómo nuestro equipo maneja las
refactorizaciones a gran escala, reduciendo errores en un 95% y completando
migraciones en horas en lugar de días.

## El Problema

Cualquier base de código de tamaño razonable exige cambios a gran escala: migrar
librerías, actualizar APIs obsoletas o refactorizar componentes. El enfoque
tradicional con IA se ve así:

```
Oye IA, por favor actualiza todos los componentes tooltip de @old-design-system a @new-design-system
```

Y entonces comienzan los problemas:

- La IA lucha por mantener el contexto a través de cientos de archivos
- El consumo de tokens explota a medida que procesa cada archivo
- Las tasas de error aumentan con la escala
- Pasas más tiempo arreglando los errores de la IA que haciendo la migración tú
  mismo

## El Mejor Enfoque

En lugar de pedir a la IA que realice la migración directamente, le pedimos que
construya una herramienta que realice la migración. Así es como funciona:

### Paso 1: Migración Manual

Primero, elige un ejemplo representativo y migra manualmente. Esto sirve para
dos propósitos:

1. Entiendes la transformación exacta necesaria
2. Tienes un ejemplo concreto para mostrar a la IA

```typescript
// Antes: Usando tooltip antiguo
import { Tooltip } from '@old-design-system';

<Tooltip content="Hola" position="top">
  <Button>Pásame el ratón</Button>
</Tooltip>

// Después: Usando tooltip nuevo
import { Tooltip } from '@new-design-system';

<Tooltip title="Hola" placement="top">
  <Button>Pásame el ratón</Button>
</Tooltip>
```

### Paso 2: Extraer el Patrón

Obtén el diff de tus cambios y documenta tanto las firmas del componente antiguo
como del nuevo:

```diff
- import { Tooltip } from '@old-design-system';
+ import { Tooltip } from '@new-design-system';

- <Tooltip content={text} position={position}>
+ <Tooltip title={text} placement={position}>
```

### Paso 3: Construir la Automatización

Ahora, en lugar de pedir a la IA que realice cientos de cambios similares, le
pedimos que construya un codemod:

```
Basado en este ejemplo de migración, construye un codemod que:
1. Actualice la declaración de importación
2. Renombre la prop 'content' a 'title'
3. Renombre la prop 'position' a 'placement'
```

La IA generará un codemod adecuado utilizando herramientas como jscodeshift que
se puede ejecutar en toda tu base de código.

## Resultados del Mundo Real

Recientemente usamos este enfoque en [**Buffer**](https://buffer.com) para
migrar componentes tooltip de nuestro sistema de diseño heredado a uno nuevo.
Los resultados fueron impresionantes:

- **95% tasa de éxito**: La mayoría de los componentes migraron perfectamente
  sin intervención manual
- **2 horas en lugar de 2 días**: Toda la migración se completó en una fracción
  del tiempo esperado
- **5% casos extremos**: Los fallos fueron casos extraños y variantes de tooltip
  heredadas que ni siquiera sabíamos que existían

Compara esto con nuestros intentos anteriores donde pedimos a la IA que hiciera
la migración directamente:

- 60% tasa de éxito
- Necesidad constante de arreglos manuales
- Límites de tokens alcanzados frecuentemente
- Transformaciones inconsistentes a través de los archivos

## Por Qué Funciona Esto

La IA sobresale en el reconocimiento de patrones y la generación de código, pero
lucha para mantener el contexto en operaciones a gran escala. Pedirle que
construya una herramienta aprovecha sus fortalezas:

1. **Tarea única enfocada**: Construir un codemod es una tarea coherente, no
   cientos de micro-tareas
2. **Abstracción de patrones**: La IA puede centrarse en entender el patrón de
   transformación en lugar de aplicarlo
3. **Salida comprobable**: Puedes probar el codemod en unos pocos archivos antes
   de ejecutarlo en todas partes
4. **Reutilizable**: El codemod se puede compartir con tu equipo o usar para
   migraciones similares

## La Belleza del Código Desechable

Nunca revisamos el código del codemod que genera la IA. ¿Por qué? Su calidad no
importa — se ejecuta una vez y se elimina después de la migración.

Este es el escenario perfecto para el "vibe coding" — dejar que la IA genere
código sin revisión. Solo importa el resultado: ¿Funcionó la migración? ¿Son
correctos los archivos transformados?

Piénsalo:

- El codemod se ejecuta una vez, luego se elimina
- Revisarás los cambios reales en tu pull request de todos modos
- Si falla, iteras
- Nadie mantiene ni construye sobre este código

Este cambio de mentalidad te libera. Salta la perfección del script de
migración; concéntrate en el código migrado.

## Una Observación Interesante

Mientras probaba Claude Code en una tarea de migración similar, noté algo
fascinante. La IA comenzó haciendo cambios archivo por archivo, pero después de
procesar unos pocos archivos, se detuvo y comenzó a escribir scripts de
migración en su lugar.

Creó múltiples scripts bash para diferentes casos extremos en lugar de un
codemod unificado — no perfecto, pero muestra que las herramientas de IA ya
reconocen estos patrones. La IA se dio cuenta autónomamente de que construir una
herramienta supera hacer la tarea manualmente.

## Cuándo Usar Este Enfoque

Esta técnica funciona mejor para:

- Migraciones de librerías
- Actualizaciones de API
- Refactorización de componentes
- Cualquier transformación repetitiva con un patrón claro

Es menos adecuada para:

- Cambios únicos
- Refactorización compleja que requiere juicio humano
- Cambios sin un patrón claro

## Conclusión

La meta-lección: haz que la IA construya la caña de pescar, no que atrape cada
pez. Cuando enfrentes un cambio de código a gran escala, resiste volcar toda la
tarea en la IA. En su lugar:

1. Haz un ejemplo manualmente
2. Haz que la IA construya la automatización
3. Revisa y ejecuta la herramienta

Este enfoque transformó cómo nuestro equipo maneja las migraciones. Los
compañeros con quienes lo comparto se maravillan de los resultados. Usa la IA
más inteligentemente, no menos.

**Artículos relacionados:**

- [Writing Powerful Claude Code Skills with npx + Bun](/writing-powerful-claude-code-skills-with-npx-bun) -
  Extiende las capacidades de IA con skills personalizados
- [Why I Switched from Bun to Deno for Claude Code Skills](/why-i-switched-from-bun-to-deno-for-claude-code-skills) -
  Consideraciones de runtime para herramientas de IA
