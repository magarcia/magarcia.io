---
title: BLoC Pattern with React Hooks
date: "2019-02-18"
spoiler:
  About how to extract the business logic from the components of a React
  application using the BLoC pattern from Flutter, the new hooks API, and RxJS
  observables.
featuredImage: bloc-schema.png
tags:
  - react
  - patterns
---

The **BLoC Pattern** has been designed by _Paolo Soares_ and _Cong Hui_, from
Google and first presented during the _DartConf 2018_ (January 23-24, 2018).
[See the video on YouTube](https://www.youtube.com/watch?v=PLHln7wHgPE "BLoC Pattern Flutter").

BLoC stands for **B**usiness **Lo**gic **C**omponent. Initially conceived to
share code between Flutter and Angular Dart, it works independently of platform:
web application, mobile application, or back-end.

It offers an alternative to the
[Redux port for flutter](https://pub.dartlang.org/packages/flutter_redux "Redux port for flutter")
using Dart streams. We'll use Observables from [RxJS](https://rxjs.dev/ "RxJS"),
though [xstream](http://staltz.github.io/xstream/ "xstream") works equally well.

In short, the BLoC will:

- contain business logic (ideally in bigger applications we will have multiple
  BLoCs)
- rely _exclusively_ on the use of _Observables_ for both input (_Observer_) and
  output (_Observable_)
- remain _platform independent_
- remain _environment independent_

## How BLoC works?

Others have explained BLoC better than I will here, so I'll cover just the
basics.

![BLoC Schema](/images/bloc-schema.png)

The BLoC holds business logic; components know nothing about its internals.
Components send _events_ to the BLoC via _Observers_ and receive notifications
via _Observables_.

## Implementing the BLoC

Here is a basic TypeScript search BLoC using RxJS:

```typescript
export class SearchBloc {
  private _results$: Observable<string[]>;
  private _preamble$: Observable<string>;
  private _query$ = new BehaviorSubject<string>("");

  constructor(private api: API) {
    this._results$ = this._query$.pipe(
      switchMap((query) => {
        return observableFrom(this.api.search(query));
      }),
    );
    this._preamble$ = this.results$.pipe(
      withLatestFrom(this._query$, (_, q) => {
        return q ? `Results for ${q}` : "All results";
      }),
    );
  }

  get results$(): Observable<string[]> {
    return this._results$;
  }

  get preamble$(): Observable<string> {
    return this._preamble$;
  }

  get query(): Observer<string> {
    return this._query$;
  }

  dispose() {
    this._query$.complete();
  }
}
```

`results$` and `preamble$` expose asynchronous values that change when `query`
changes.

`query` exposes an `Observer<string>` for components to add new values. Inside
`SearchBloc`, `_query$: BehaviorSubject<string>` serves as the stream source,
and the constructor declares `_results$` and `_preamble$` to respond to
`_query$`.

## Using it on React

To use it in React, create a BLoC instance and share it with child components
via React context.

```jsx
const searchBloc = new SearchBloc(new API());
const SearchContext = React.createContext(searchBloc);
```

Expose it using the context provider:

```jsx
const App = () => {
  const searchBloc = useContext(SearchContext);

  useEffect(() => {
    return searchBloc.dispose;
  }, [searchBloc]);

  return (
    <SearchContext.Provider>
      <SearchInput />
      <ResultList />
    </SearchContext.Provider>
  );
};
```

The `useEffect` returns the dispose method, completing the observer when the
component unmounts.

Publish changes to the BLoC from the `SearchInput` component:

```jsx
const SearchInput = () => {
  const searchBloc = useContext(SearchContext);
  const [query, setQuery] = useState("");

  useEffect(() => {
    searchBloc.query.next(query);
  }, [searchBloc, query]);

  return (
    <input
      type="text"
      name="Search"
      value={query}
      onChange={({ target }) => setQuery(target.value)}
    />
  );
};
```

We get the BLoC via `useContext`, then `useEffect` publishes each query change
to the BLoC.

Now the `ResultList`:

```jsx
const ResultList = () => {
  const searchBloc = useContext(SearchContext);
  const [results, setResults] = useState([]);

  useEffect(() => {
    return searchBloc.results$.subscribe(setResults);
  }, [searchBloc]);

  return (
    <div>
      {results.map(({ id, name }) => (
        <div key={id}>{name}</div>
      ))}
    </div>
  );
};
```

We use `useContext` to get the BLoC, then `useEffect` subscribes to `results$`
changes to update local state. Returning the subscription unsubscribes when the
component unmounts.

## Final thoughts

The final code is straightforward with basic knowledge of _Observables_ and
_hooks_. The code is readable and keeps business logic outside components. We
must remember to unsubscribe from observables and dispose the BLoC on unmount,
but custom hooks like `useBlocObservable` and `useBlocObserver` could solve
this. I plan to try this in a side project where I use this pattern.
