---
title: Patrón BLoC con React Hooks
date: "2019-02-18"
spoiler:
  Sobre cómo extraer la lógica de negocio de los componentes de una aplicación
  React usando el patrón BLoC de Flutter, la nueva API de hooks y observables
  RxJS.
featuredImage: bloc-schema.png
tags:
  - react
  - patterns
---

El **Patrón BLoC** ha sido diseñado por _Paolo Soares_ y _Cong Hui_, de Google y
presentado por primera vez durante la _DartConf 2018_ (23-24 de enero de 2018).
[Ver el vídeo en YouTube](https://www.youtube.com/watch?v=PLHln7wHgPE "BLoC Pattern Flutter").

BLoC significa **B**usiness **Lo**gic **C**omponent (Componente de Lógica de
Negocio). Inicialmente concebido para compartir código entre Flutter y Angular
Dart, funciona independientemente de la plataforma: aplicación web, aplicación
móvil o back-end.

Ofrece una alternativa al
[puerto de Redux para flutter](https://pub.dartlang.org/packages/flutter_redux "Redux port for flutter")
usando streams de Dart. Usaremos Observables de
[RxJS](https://rxjs.dev/ "RxJS"), aunque
[xstream](http://staltz.github.io/xstream/ "xstream") funciona igualmente bien.

En resumen, el BLoC:

- contendrá lógica de negocio (idealmente en aplicaciones más grandes tendremos
  múltiples BLoCs)
- dependerá _exclusivamente_ del uso de _Observables_ tanto para entrada
  (_Observer_) como para salida (_Observable_)
- permanecerá _independiente de la plataforma_
- permanecerá _independiente del entorno_

## ¿Cómo funciona BLoC?

Otros han explicado BLoC mejor que yo, así que cubriré solo lo básico.

![Esquema BLoC](/images/bloc-schema.png)

El BLoC mantiene la lógica de negocio; los componentes desconocen sus internos.
Los componentes envían _eventos_ al BLoC vía _Observers_ y reciben
notificaciones vía _Observables_.

## Implementando el BLoC

Aquí está un BLoC de búsqueda básico en TypeScript usando RxJS:

```typescript
export class SearchBloc {
  private _results$: Observable<string[]>;
  private _preamble$: Observable<string>;
  private _query$ = new BehaviorSubject<string>("");

  constructor(private api: API) {
    this._results$ = this._query$.pipe(
      switchMap((query) => {
        return observableFrom(this.api.search(query));
      }),
    );
    this._preamble$ = this.results$.pipe(
      withLatestFrom(this._query$, (_, q) => {
        return q ? `Resultados para ${q}` : "Todos los resultados";
      }),
    );
  }

  get results$(): Observable<string[]> {
    return this._results$;
  }

  get preamble$(): Observable<string> {
    return this._preamble$;
  }

  get query(): Observer<string> {
    return this._query$;
  }

  dispose() {
    this._query$.complete();
  }
}
```

`results$` y `preamble$` exponen valores asíncronos que cambian cuando `query`
cambia.

`query` expone un `Observer<string>` para que los componentes añadan nuevos
valores. Dentro de `SearchBloc`, `_query$: BehaviorSubject<string>` sirve como
fuente del stream, y el constructor declara `_results$` y `_preamble$` para
responder a `_query$`.

## Usándolo en React

Para usarlo en React, crea una instancia del BLoC y compártela con los
componentes hijos vía contexto de React.

```jsx
const searchBloc = new SearchBloc(new API());
const SearchContext = React.createContext(searchBloc);
```

Expónlo usando el proveedor de contexto:

```jsx
const App = () => {
  const searchBloc = useContext(SearchContext);

  useEffect(() => {
    return searchBloc.dispose;
  }, [searchBloc]);

  return (
    <SearchContext.Provider>
      <SearchInput />
      <ResultList />
    </SearchContext.Provider>
  );
};
```

El `useEffect` devuelve el método dispose, completando el observer cuando el
componente se desmonta.

Publica cambios al BLoC desde el componente `SearchInput`:

```jsx
const SearchInput = () => {
  const searchBloc = useContext(SearchContext);
  const [query, setQuery] = useState("");

  useEffect(() => {
    searchBloc.query.next(query);
  }, [searchBloc, query]);

  return (
    <input
      type="text"
      name="Search"
      value={query}
      onChange={({ target }) => setQuery(target.value)}
    />
  );
};
```

Obtenemos el BLoC vía `useContext`, luego `useEffect` publica cada cambio de
consulta al BLoC.

Ahora el `ResultList`:

```jsx
const ResultList = () => {
  const searchBloc = useContext(SearchContext);
  const [results, setResults] = useState([]);

  useEffect(() => {
    return searchBloc.results$.subscribe(setResults);
  }, [searchBloc]);

  return (
    <div>
      {results.map(({ id, name }) => (
        <div key={id}>{name}</div>
      ))}
    </div>
  );
};
```

Usamos `useContext` para obtener el BLoC, luego `useEffect` se suscribe a los
cambios de `results$` para actualizar el estado local. Devolver la suscripción
cancela la suscripción cuando el componente se desmonta.

## Pensamientos finales

El código final es directo con conocimiento básico de _Observables_ y _hooks_.
El código es legible y mantiene la lógica de negocio fuera de los componentes.
Debemos recordar desuscribirnos de los observables y desechar el BLoC al
desmontar, pero hooks personalizados como `useBlocObservable` y
`useBlocObserver` podrían resolver esto. Planeo probarlo en un proyecto paralelo
donde uso este patrón.
