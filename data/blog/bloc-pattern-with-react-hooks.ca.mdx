---
title: Patró BLoC amb React Hooks
date: "2019-02-18"
spoiler:
  Sobre com extreure la lògica de negoci dels components d'una aplicació React
  utilitzant el patró BLoC de Flutter, la nova API de hooks i observables RxJS.
featuredImage: bloc-schema.png
tags:
  - react
  - patterns
---

El **Patró BLoC** ha estat dissenyat per _Paolo Soares_ i _Cong Hui_, de Google
i presentat per primera vegada durant la _DartConf 2018_ (23-24 de gener de
2018).
[Veure el vídeo a YouTube](https://www.youtube.com/watch?v=PLHln7wHgPE "BLoC Pattern Flutter").

BLoC significa **B**usiness **Lo**gic **C**omponent (Component de Lògica de
Negoci). Inicialment concebut per compartir codi entre Flutter i Angular Dart,
funciona independentment de la plataforma: aplicació web, aplicació mòbil o
back-end.

Ofereix una alternativa al
[port de Redux per a flutter](https://pub.dartlang.org/packages/flutter_redux "Redux port for flutter")
utilitzant streams de Dart. Utilitzarem Observables de
[RxJS](https://rxjs.dev/ "RxJS"), tot i que
[xstream](http://staltz.github.io/xstream/ "xstream") funciona igualment bé.

En resum, el BLoC:

- contindrà lògica de negoci (idealment en aplicacions més grans tindrem
  múltiples BLoCs)
- dependrà _exclusivament_ de l'ús d'_Observables_ tant per a entrada
  (_Observer_) com per a sortida (_Observable_)
- romandrà _independent de la plataforma_
- romandrà _independent de l'entorn_

## Com funciona BLoC?

Altres han explicat BLoC millor que jo, així que cobriré només el bàsic.

![Esquema BLoC](/images/bloc-schema.png)

El BLoC manté la lògica de negoci; els components desconeixen els seus
internals. Els components envien _esdeveniments_ al BLoC via _Observers_ i reben
notificacions via _Observables_.

## Implementant el BLoC

Aquí està un BLoC de cerca bàsic en TypeScript utilitzant RxJS:

```typescript
export class SearchBloc {
  private _results$: Observable<string[]>;
  private _preamble$: Observable<string>;
  private _query$ = new BehaviorSubject<string>("");

  constructor(private api: API) {
    this._results$ = this._query$.pipe(
      switchMap((query) => {
        return observableFrom(this.api.search(query));
      }),
    );
    this._preamble$ = this.results$.pipe(
      withLatestFrom(this._query$, (_, q) => {
        return q ? `Resultats per a ${q}` : "Tots els resultats";
      }),
    );
  }

  get results$(): Observable<string[]> {
    return this._results$;
  }

  get preamble$(): Observable<string> {
    return this._preamble$;
  }

  get query(): Observer<string> {
    return this._query$;
  }

  dispose() {
    this._query$.complete();
  }
}
```

`results$` i `preamble$` exposen valors asíncrons que canvien quan `query`
canvia.

`query` exposa un `Observer<string>` perquè els components afegeixin nous
valors. Dins de `SearchBloc`, `_query$: BehaviorSubject<string>` serveix com a
font del stream, i el constructor declara `_results$` i `_preamble$` per
respondre a `_query$`.

## Utilitzant-lo en React

Per utilitzar-lo en React, crea una instància del BLoC i comparteix-la amb els
components fills via context de React.

```jsx
const searchBloc = new SearchBloc(new API());
const SearchContext = React.createContext(searchBloc);
```

Exposa'l utilitzant el proveïdor de context:

```jsx
const App = () => {
  const searchBloc = useContext(SearchContext);

  useEffect(() => {
    return searchBloc.dispose;
  }, [searchBloc]);

  return (
    <SearchContext.Provider>
      <SearchInput />
      <ResultList />
    </SearchContext.Provider>
  );
};
```

El `useEffect` retorna el mètode dispose, completant l'observer quan el
component es desmunta.

Publica canvis al BLoC des del component `SearchInput`:

```jsx
const SearchInput = () => {
  const searchBloc = useContext(SearchContext);
  const [query, setQuery] = useState("");

  useEffect(() => {
    searchBloc.query.next(query);
  }, [searchBloc, query]);

  return (
    <input
      type="text"
      name="Search"
      value={query}
      onChange={({ target }) => setQuery(target.value)}
    />
  );
};
```

Obtenim el BLoC via `useContext`, després `useEffect` publica cada canvi de
consulta al BLoC.

Ara el `ResultList`:

```jsx
const ResultList = () => {
  const searchBloc = useContext(SearchContext);
  const [results, setResults] = useState([]);

  useEffect(() => {
    return searchBloc.results$.subscribe(setResults);
  }, [searchBloc]);

  return (
    <div>
      {results.map(({ id, name }) => (
        <div key={id}>{name}</div>
      ))}
    </div>
  );
};
```

Utilitzem `useContext` per obtenir el BLoC, després `useEffect` es subscriu als
canvis de `results$` per actualitzar l'estat local. Retornar la subscripció
cancel·la la subscripció quan el component es desmunta.

## Pensaments finals

El codi final és directe amb coneixement bàsic d'_Observables_ i _hooks_. El
codi és llegible i manté la lògica de negoci fora dels components. Hem de
recordar dessubscriure'ns dels observables i descartar el BLoC al desmuntar,
però hooks personalitzats com `useBlocObservable` i `useBlocObserver` podrien
resoldre això. Planejo provar-ho en un projecte paral·lel on utilitzo aquest
patró.
