---
title: "Why I Switched from Bun to Deno for Claude Code Skills"
date: "2026-01-15"
spoiler: "Bun's auto-install breaks when any node_modules directory exists in parent paths—a footgun for portable skills. Deno's npm: specifier works everywhere, from project directories to monorepos, without surprises."
tags:
  - typescript
  - deno
  - bun
  - ai
  - developer-tools
---

Last week I wrote about [using npx bun to write Claude Code skills](/writing-powerful-claude-code-skills-with-npx-bun) with third-party dependencies. The approach worked well for simple cases—self-contained TypeScript scripts with auto-installing packages, no build step required. But after using it in real environments, I discovered a significant problem.

Bun's auto-install only works when no `node_modules` directory exists in the working directory or any parent directory. When `node_modules` is present anywhere up the tree, Bun switches to standard Node.js module resolution. Version specifiers in imports—the core feature that made the approach useful—throw `VersionSpecifierNotAllowedHere` errors.

This breaks in practical scenarios. Run a skill from within a project directory? Broken. Work in a monorepo where some ancestor has `node_modules`? Broken. Your home directory happens to have an old `node_modules` from a forgotten experiment? Broken.

For portable Claude Code skills that might run from anywhere, this is a footgun. The script works when you test it in `~/.claude/skills/`, then fails mysteriously when Claude invokes it from a different directory. The error message doesn't make the problem obvious—you have to understand Bun's internal resolution logic to diagnose it.

## Why Deno Solves This

Deno's `npm:` specifier works regardless of whether `node_modules` exists. Dependencies always go to Deno's global cache at `~/.cache/deno`. The presence or absence of local `node_modules` directories is irrelevant. You get consistent behavior across all environments.

The same `npx` distribution trick works. Just like `npx -y bun`, you can use `npx -y deno` to run Deno without installing it globally. Any environment with npm can execute Deno scripts.

## The Deno Approach

Here's what a Deno-based skill looks like:

```typescript
#!/usr/bin/env -S npx -y deno run --allow-read --allow-write

import { parse } from "npm:csv-parse@^5.0/sync"
import chalk from "npm:chalk@^5.0.0"
import { z } from "npm:zod@^3.23"

const inputPath = Deno.args[0]
const content = await Deno.readTextFile(inputPath)

const rows = parse(content, { columns: true })
console.log(chalk.green(`Parsed ${rows.length} rows`))
```

The `npm:` prefix is more verbose than Bun's bare imports, but it's explicit about where packages come from. TypeScript works natively. Version pinning lives in the import path, same as with Bun.

Deno requires permission flags—`--allow-read`, `--allow-write`, `--allow-net`, etc. This is more verbose than Bun's default-permissive approach, but it also means you declare exactly what the script does. For skills that run with elevated privileges through Claude Code, knowing the script can't make network requests or modify files outside specific directories is useful.

## Trade-offs

| Aspect | Bun | Deno |
|--------|-----|------|
| Import syntax | `import x from "pkg@1.0"` | `import x from "npm:pkg@1.0"` |
| node_modules safe | No | Yes |
| Raw performance | ~20-30% faster | Slightly slower |
| TypeScript | Native | Native |
| Permissions model | Permissive by default | Explicit flags required |
| Node.js compatibility | Partial, evolving | High, via compatibility layer |

Bun is faster. Startup time, runtime performance, HTTP serving—Bun consistently beats Deno in benchmarks. If you're building a production API or a performance-critical CLI tool, that matters.

For Claude Code skills, it doesn't.

## Why Performance Doesn't Matter Here

Skills are IO-bound. They read files, call APIs, parse data, write output. The bottleneck is disk access and network latency, not JavaScript execution speed.

More importantly, the agent's thinking time dwarfs script execution time. Claude takes two to five seconds to decide what to do next. A skill that runs in 50 milliseconds versus 80 milliseconds is effectively the same—both are instant compared to the agent's decision loop.

If your skill parsed gigabytes of data or served thousands of requests per second, Bun's speed advantage would matter. But most skills are glue code—fetch this API, parse that file, format this output. The difference between Bun and Deno is lost in the noise.

Reliability matters more. A skill that works from any directory is more valuable than a skill that's 30% faster but breaks in monorepos.

## Practical Example for Skills

Structure your skill like this:

```
data-processor/
├── SKILL.md
└── scripts/
    └── process.ts
```

In `SKILL.md`:

```markdown
---
name: data-processor
description: Process data files with third-party libraries
allowed-tools: [Bash, Read, Write]
---

# Data Processor

Run the processing script:

```bash
./scripts/process.ts <input-file>
```
```

In `scripts/process.ts`:

```typescript
#!/usr/bin/env -S npx -y deno run --allow-read --allow-write

import { parse } from "npm:csv-parse@^5.0/sync"
import * as XLSX from "npm:xlsx@^0.20"

const inputPath = Deno.args[0]
const content = await Deno.readTextFile(inputPath)

const rows = parse(content, { columns: true })
console.log(JSON.stringify(rows, null, 2))
```

Claude runs the skill, the script executes with full access to npm packages, and it works regardless of where Claude invokes it from.

## When to Still Use Bun

If you control the execution environment and can guarantee no `node_modules` directories exist in parent paths, Bun is still a good choice. Skills stored exclusively in `~/.claude/skills/` with no other code nearby fit this profile.

If you're already working in a Bun-native project—building an API, running tests, using Bun for development—scripts that stay within that project can use Bun's auto-install without issues.

If performance actually matters for your use case—processing large datasets, running computationally expensive algorithms, serving high-throughput APIs—Bun's speed advantage is real and measurable.

But for portable skills that might run from anywhere, Deno's consistency is more valuable than Bun's speed.

## Conclusion

The `npm:` prefix is more verbose. Permission flags add ceremony. Bun's import syntax is cleaner and faster. But Deno's reliability across different directory structures makes it the better choice for Claude Code skills.

You don't have to debug why a skill works in one directory and fails in another. You don't have to document "this only works outside of projects with node_modules." The script just works.

For the original goal—self-contained TypeScript scripts with third-party dependencies, no build step, available anywhere npm runs—Deno delivers without the gotchas.

## References

- [Writing Powerful Claude Code Skills with npx bun](/writing-powerful-claude-code-skills-with-npx-bun) — The original exploration of this approach
- [Deno — A modern runtime for JavaScript and TypeScript](https://deno.land)
- [Deno npm compatibility](https://docs.deno.com/runtime/fundamentals/node/#using-npm-packages) — How the `npm:` specifier works
- [Bun Auto-Install Documentation](https://bun.sh/docs/runtime/auto-install) — Understanding when auto-install activates
- [Claude Code Skills Documentation](https://docs.anthropic.com/en/docs/claude-code/skills)
